
Проверь безопасность этого проекта ОЧЕНЬ ДОТОШНО. Действуй как параноидальный аудитор: предполагай, что всё может быть уязвимо, и проверяй каждый пункт по факту в коде и конфигах.

Проект: Flutter-чат с Node.js бэкендом (Express), PostgreSQL, WebSocket, деплой на Yandex Cloud (ВМ + Managed PostgreSQL), фронт на Vercel. Есть скрипты деплоя, SSH-ключи, GitHub Actions.

Выполни проверку по всем категориям ниже. По каждой категории: (1) что именно проверял, (2) результат (OK / предупреждение / уязвимость), (3) конкретные файлы и строки, (4) рекомендации или патч. В конце дай сводную таблицу и список действий по приоритету.

---

### 1. Секреты и учётные данные

- Все ли пароли, ключи, токены, строки подключения к БД вынесены из кода и лежат только в .env / переменных окружения? Нет ли хардкода в коде, конфигах, тестах?
- Есть ли в репозитории (в т.ч. в истории коммитов) файлы .env, *.pem, *credentials*, приватные SSH-ключи, токены DuckDNS/API? Проверь .gitignore: перечислены ли все файлы с секретами (в т.ч. env-yandex-vm.txt, vm-connection.txt, scripts/.deploy_key)?
- Нет ли в документации (.md, .txt) вшитых паролей, токенов, полных DATABASE_URL с паролем, приватных ключей? Нет ли в примерах кода реальных секретов?
- Используется ли .env.example / .env.template без реальных значений? Нет ли в них случайно подставленных реальных ключей?
- Где и как хранится JWT_SECRET: только в окружении на сервере? Нет ли дефолтного или тестового значения в коде?
- Проверь все вхождения строк типа password, secret, token, api_key, DATABASE_URL, Authorization в репозитории (кроме node_modules) — нет ли утечки значений.

---

### 2. Бэкенд: аутентификация и авторизация

- Пароли хранятся только в виде хеша (bcrypt и т.п.)? Нет ли логирования паролей (даже в development)?
- JWT: задаётся ли явно algorithm (например HS256)? Есть ли защита от alg:none? Проверяется ли длина токена до jwt.verify (защита от DoS)?
- Все ли эндпоинты, требующие авторизации, защищены middleware (authenticateToken)? Нет ли маршрутов с чувствительными данными без проверки токена?
- userId и другие идентификаторы пользователя берутся только из токена (req.user), а не из body/query/params? Нет ли IDOR (доступ к чужим чатам/сообщениям по подмене id в запросе)?
- Суперпользователь и привилегированные действия: проверка через requireSuperuser / аналог; нет ли обхода через другой эндпоинт?
- WebSocket: проверяется ли токен при подключении? Нет ли доступа к чужим комнатам/чатам по подмене chatId в сообщении?

---

### 3. Бэкенд: ввод и инъекции

- Все ли запросы к БД используют параметризованные запросы ($1, $2, ...)? Нет ли конкатенации строки SQL с пользовательским вводом?
- Валидация и санитизация: проверяются ли типы и границы для всех входных данных (id — целое положительное, строки — длина, массивы — размер)? Есть ли защита от null-byte, управляющих символов, zero-width в именах и текстах?
- Загрузка файлов: проверка MIME-type и расширения; запрет исполняемых и опасных типов (в т.ч. SVG с script); лимит размера файла и тела запроса; нет ли path traversal при сохранении?
- Нет ли в ответах API утечки внутренних деталей: stack trace, error.message с путями, версии библиотек? Обработчики 404/500 отдают нейтральное сообщение?

---

### 4. Бэкенд: CORS, заголовки, rate limit

- CORS: список разрешённых origin задаётся из конфигурации (ALLOWED_ORIGINS); нет ли в production разрешения * или излишне широких паттернов? Учитываются ли только нужные домены фронта?
- Заголовки безопасности: X-Frame-Options, X-Content-Type-Options, HSTS в production, убран ли X-Powered-By?
- Rate limit: есть ли лимиты на логин/регистрацию (защита от брутфорса), на общие API, на загрузки и на чувствительные действия (смена пароля, удаление аккаунта)? Учтён ли trust proxy для правильного IP?

---

### 5. Логирование и PII

- В логах (в т.ч. audit/security) не попадают пароли, токены, полные cookie? Не логируются ли в production логины/email при неудачной попытке входа или регистрации?
- Логи ошибок: не выводятся ли в них фрагменты тела запроса или заголовки с токенами?

---

### 6. Фронт и клиент

- Токен хранится безопасно (secure storage / не в localStorage на веб, если есть риск XSS)? Нет ли токена в URL на постоянной основе (только при одноразовой передаче в WebSocket, если необходимо)?
- В коде фронта нет хардкода API-ключей, паролей, секретов? Базовый URL API задаётся через конфиг / dart-define, а не зашит в виде продакшен-секрета?
- Нет ли в сборке (build) или в публичных артефактах вшитых .env или ключей?

---

### 7. Инфраструктура и деплой

- Скрипты деплоя и документация: не содержат ли реальных паролей или приватных ключей? Публичный SSH-ключ в cloud-init — допустим; приватный не должен быть в репо.
- GitHub Actions: секреты (DEPLOY_SSH_KEY и т.д.) используются только через secrets, не захардкожены в workflow? В логах workflow не выводятся ли секреты?
- Нет ли в открытых конфигах (vercel.json, yml workflow) чувствительных данных?

---

### 8. Зависимости

- Выполни npm audit (и при необходимости npm audit fix) в каталоге бэкенда. Критические и высокие уязвимости должны быть устранены или задокументированы с обоснованием.
- Нет ли известных уязвимых версий ключевых пакетов (express, jsonwebtoken, pg, bcrypt, multer и т.д.)? Проверь по актуальным CVE.

---

### 9. Прочее

- Нет ли опасных вызовов: eval, Function('...'), child_process.exec с пользовательским вводом, нефильтрованный require по пользовательским данным?
- Проверь, что чувствительные эндпоинты (например сброс пароля, настройка CORS) защищены не только токеном, но и проверкой роли/суперпользователя.
- Есть ли ограничения на размер тела запроса, длину строк в полях, количество элементов в массивах (userIds, payments и т.д.)?

---

Итог: по каждой категории — краткий вердикт (OK / предупреждение / уязвимость), список файлов и строк, затем сводная таблица и приоритизированный список исправлений. Если что-то нельзя исправить кодом — явно сформулируй рекомендацию (документация, настройка окружения, процесс).
```

---

## Как использовать

1. Открой чат с ассистентом (Cursor / другой AI).
2. Вставь весь блок промпта (от «Проверь безопасность» до конца).
3. Ассистент пройдёт по чек-листу, проверит код и конфиги и выдаст отчёт.
4. При необходимости скопируй вывод отчёта в отдельный файл (например `docs/SECURITY_AUDIT_YYYY-MM-DD.md`) для истории.

При повторных аудитах можно добавить в конец промпта: «Учти предыдущий отчёт из docs/SECURITY_COMPLETE.md и docs/SECURITY_AUDIT_*.md — проверь, что исправления применены и новых регрессий нет.»

Перед коммитом рекомендуется запускать: `bash scripts/check-no-secrets-staged.sh` (проверка, что в индекс не попали файлы с секретами). При каждом push и pull_request те же проверки выполняются автоматически в GitHub Actions (workflow **Security check**): секреты не в репо, npm audit без высоких/критических уязвимостей.
